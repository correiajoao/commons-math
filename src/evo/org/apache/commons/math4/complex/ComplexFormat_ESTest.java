/*
 * This file was automatically generated by EvoSuite
 * Mon Feb 24 19:18:43 GMT 2020
 */

package org.apache.commons.math4.complex;

import org.apache.commons.math4.complex.ComplexFormat;
import org.apache.commons.numbers.complex.Complex;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.math.RoundingMode;
import java.util.Locale;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class ComplexFormat_ESTest extends ComplexFormat_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o erro de conversão de um Valor real para Complexo gera o index e a mensagem de erro esperada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
        ComplexFormat complexFormat0 = new ComplexFormat("811.737", numberFormat0, numberFormat0);
        ParsePosition parsePosition0 = new ParsePosition(1);
        complexFormat0.parse("811.737", parsePosition0);
        assertEquals(3, parsePosition0.getErrorIndex());
        assertEquals("java.text.ParsePosition[index=1,errorIndex=3]", parsePosition0.toString());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a conversão de uma expressão gera o resultado e o caracter imaginário esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test01() throws Throwable {
        DecimalFormat decimalFormat0 = new DecimalFormat();
        ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0);
        Complex complex0 = complexFormat0.parse("-835.516 - 835.516i");
        assertEquals((-2.356194490192345), complex0.arg(), 0.01);
        assertEquals("i", complexFormat0.getImaginaryCharacter());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste passa carcteres aleatórios para em seguida verificiar a função getRoundingMode()
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        DecimalFormat decimalFormat0 = new DecimalFormat("5Q~zY{]uL>");
        ComplexFormat complexFormat0 = new ComplexFormat("5Q~zY{]uL>", decimalFormat0, decimalFormat0);
        NumberFormat numberFormat0 = complexFormat0.getRealFormat();
        assertEquals(RoundingMode.HALF_EVEN, numberFormat0.getRoundingMode());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se o
    *     caractere imaginário é o esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        Locale locale0 = Locale.ITALIAN;
        NumberFormat numberFormat0 = NumberFormat.getCurrencyInstance(locale0);
        ComplexFormat complexFormat0 = new ComplexFormat(numberFormat0, numberFormat0);
        complexFormat0.getRealFormat();
        assertEquals("i", complexFormat0.getImaginaryCharacter());
    }
    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se o
    *     caractere imaginário é o esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        NumberFormat numberFormat0 = NumberFormat.getCurrencyInstance();
        ComplexFormat complexFormat0 = new ComplexFormat(numberFormat0);
        complexFormat0.getImaginaryFormat();
        assertEquals("i", complexFormat0.getImaginaryCharacter());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     parse() chamada com argumentos ilegais lança uma StringIndexOutOfBoundsException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        ComplexFormat complexFormat0 = new ComplexFormat("QyYug*/d?bCNj3N.W");
        ParsePosition parsePosition0 = new ParsePosition(0);
        parsePosition0.setIndex((-2192));
        // Undeclared exception!
        try {
            complexFormat0.parse(" - ", parsePosition0);
            fail("Expecting exception: StringIndexOutOfBoundsException");

        } catch (StringIndexOutOfBoundsException e) {
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     parse() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        Locale locale0 = Locale.PRC;
        NumberFormat numberFormat0 = NumberFormat.getPercentInstance(locale0);
        ComplexFormat complexFormat0 = new ComplexFormat(numberFormat0);
        // Undeclared exception!
        try {
            complexFormat0.parse("BINOMIAL_INVALID_PARAMETERS_ORDER", (ParsePosition) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     parse() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        ComplexFormat complexFormat0 = new ComplexFormat();
        // Undeclared exception!
        try {
            complexFormat0.parse((String) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.apache.commons.math4.util.CompositeFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     getInstance() chamada com argumentos ilegais lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        // Undeclared exception!
        try {
            ComplexFormat.getInstance(")AGYW0N6)syt0NKE", (Locale) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     format() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     Tanto o comportamento do teste e quanto as suas instruções demandam muito esforço para o entendimento.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        ComplexFormat complexFormat0 = ComplexFormat.getInstance();
        StringBuffer stringBuffer0 = new StringBuffer();
        Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
        FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
        // Undeclared exception!
        try {
            complexFormat0.format((Complex) null, stringBuffer0, fieldPosition0);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     format() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - Tanto o comportamento do teste e quanto as suas instruções demandam muito esforço para o entendimento.
    */
    @Test(timeout = 4000)
    public void test14() throws Throwable {
        ChoiceFormat choiceFormat0 = new ChoiceFormat("NON_POSITIVE_DEFINITE_OPERATOR");
        ComplexFormat complexFormat0 = new ComplexFormat("NON_POSITIVE_DEFINITE_OPERATOR", choiceFormat0, choiceFormat0);
        Complex complex0 = Complex.I;
        Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
        FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2273);
        // Undeclared exception!
        try {
            complexFormat0.format(complex0, (StringBuffer) null, fieldPosition0);
            fail("Expecting exception: ArrayIndexOutOfBoundsException");

        } catch (ArrayIndexOutOfBoundsException e) {
            //
            // 0
            //
            verifyException("java.text.ChoiceFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     format() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test15() throws Throwable {
        DecimalFormat decimalFormat0 = new DecimalFormat();
        ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0, decimalFormat0);
        // Undeclared exception!
        try {
            complexFormat0.format((Complex) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se a função
    *     format() chamada com argumentos ilegais lança uma NullPointerException. A documentação especifica que para erros
    *     nos valores passados uma MathParseException será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test18() throws Throwable {
        ComplexFormat complexFormat0 = new ComplexFormat();
        Complex complex0 = Complex.ofCartesian(1.0, 1.0);
        StringBuffer stringBuffer0 = new StringBuffer();
        // Undeclared exception!
        try {
            complexFormat0.format((Object) complex0, stringBuffer0, (FieldPosition) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se o construtor
    *     ComplexFormat() chamada com argumentos ilegais lança uma NullPointerException. A documentação diz que nesses casos uma
     *    NullArgumentException  será lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test22() throws Throwable {
        ComplexFormat complexFormat0 = null;
        try {
            complexFormat0 = new ComplexFormat((String) null);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // null is not allowed
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se o construtor
    *     ComplexFormat() com String vazia lança uma RuntimeException. A documentação diz que nesses casos uma NoDataException será
    *     lançada.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test23() throws Throwable {
        ComplexFormat complexFormat0 = null;
        try {
            complexFormat0 = new ComplexFormat("");
            fail("Expecting exception: RuntimeException");

        } catch (RuntimeException e) {
            //
            // no data
            //
            verifyException("org.apache.commons.math4.complex.ComplexFormat", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se o construtor
    *     ComplexFormat() com String vazia lança uma RuntimeException. A documentação diz que nesses casos uma NoDataException será
    *     lançada.
    *
    * Compreensivel: não
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test24() throws Throwable {
        DecimalFormat decimalFormat0 = new DecimalFormat();
        ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0);
        ParsePosition parsePosition0 = new ParsePosition(4);
        Complex complex0 = complexFormat0.parse("-835.516 - 835.516i", parsePosition0);
        assertEquals(19, parsePosition0.getIndex());
        assertEquals((-1.5701787444453092), complex0.arg(), 0.01);
    }

    /*
   * Informações do teste
   *
   * Plausível: sim
   *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
   *     a conversão de um valor gera o resultado e o caracter imaginário esperado.
   *
   * Compreensivel: sim
   *     - O comportamento do teste e suas instruções são compreesíveis.
   */
    @Test(timeout = 4000)
    public void test25() throws Throwable {
        ComplexFormat complexFormat0 = new ComplexFormat();
        ParsePosition parsePosition0 = new ParsePosition(1);
        Complex complex0 = complexFormat0.parse("0", parsePosition0);
        assertEquals("i", complexFormat0.getImaginaryCharacter());
        assertEquals(0.0, complex0.norm(), 0.01);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica dois comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a conversão de uma expressão gera o resultado esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */

    @Test(timeout = 4000)
    public void test26() throws Throwable {
        DecimalFormat decimalFormat0 = new DecimalFormat();
        ComplexFormat complexFormat0 = new ComplexFormat(decimalFormat0);
        ParsePosition parsePosition0 = new ParsePosition(4);
        Complex complex0 = complexFormat0.parse("0.989 + 0.148i", parsePosition0);
        assertEquals(14, parsePosition0.getIndex());
        assertEquals(9.001216806632312, complex0.abs(), 0.01);
    }
    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste utiliza estratégias muito elaboradas para realizar suas verificações.
    *
    * Compreensivel: não
    *     - O comportamento do teste é de difícil compreensão.
    */

    @Test(timeout = 4000)
    public void test27() throws Throwable {
        Locale locale0 = Locale.CANADA;
        ComplexFormat complexFormat0 = ComplexFormat.getInstance(locale0);
        Complex complex0 = Complex.ofCartesian(67, 67);
        StringBuffer stringBuffer0 = new StringBuffer(67);
        FieldPosition fieldPosition0 = new FieldPosition(67);
        complexFormat0.format(complex0, stringBuffer0, fieldPosition0);
        assertEquals("67 + 67i", stringBuffer0.toString());
        assertEquals(8, stringBuffer0.length());
    }
    /*
   * Informações do teste
   *
   * Plausível: não
   *     - O teste utiliza estratégias muito elaboradas para realizar suas verificações.
   *
   * Compreensivel: não
   *     - O comportamento do teste é de difícil compreensão.
   */
    @Test(timeout = 4000)
    public void test28() throws Throwable {
        NumberFormat numberFormat0 = NumberFormat.getIntegerInstance();
        ComplexFormat complexFormat0 = new ComplexFormat("Q", numberFormat0, numberFormat0);
        Complex complex0 = Complex.ofPolar((-2227.5), (-2227.5));
        StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "Q");
        FieldPosition fieldPosition0 = new FieldPosition(45);
        complexFormat0.format(complex0, stringBuffer0, fieldPosition0);
        assertEquals("Q(NaN) + (NaN)Q", stringBuffer0.toString());
        assertEquals(15, stringBuffer0.length());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste utiliza estratégias muito elaboradas para realizar suas verificações.
    *
    * Compreensivel: não
    *     - O comportamento do teste é de difícil compreensão.
    */
    @Test(timeout = 4000)
    public void test38() throws Throwable {
        Locale locale0 = new Locale("439.4180563514", "439.4180563514", "439.4180563514");
        ComplexFormat complexFormat0 = ComplexFormat.getInstance("439.4180563514", locale0);
        Complex complex0 = complexFormat0.parse("0.8213695368 - 0.5703964271439.4180563514");
        assertNull(complex0);
    }
}
